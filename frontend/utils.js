/* Creation date:        2022-01-15
 * Contributors:         Jean-Marc Andreoli
 * Language:             javascript
 * Purpose:              Xpose: client side utilities
 */

async function upload(x) {
  // x: object with the following fields
  //   file: a File or Blob object
  //   url: must support POST with blob content and optional target in query string (generated by the server if not provided)
  //   chunk (default 1): int, in MiB
  //   target (optional): target file name
  //   progress (optional): progress callback with one input (percent_complete)
  // Sends the file (method POST) by chunks to the given url assumed to return a result object for each chunk
  // A result object describes the uploaded file after each chunk transfer with 3 fields:
  //   name (invariable), mtime (last modification time), size (in bytes)
  // Returns (a promise on) the last result object (after all tranfers)
  const file = x.file, url = x.url, progress = x.progress, chunk = (x.chunk||1)*0x100000
  const req = {method:'POST',headers:{'Content-Type':'application/octet-stream'}}, size = file.size
  let target = x.target||'', position = 0, nextPosition = 0, result = null, ongoing = true
  if (progress) {
    const controller = new AbortController()
    req.signal = controller.signal
    req.onUploadProgress = (evt)=>{if(progress((position+evt.loaded)/size)){controller.abort()}}
  }
  while(ongoing) {
    nextPosition = position+chunk
    if (nextPosition>=size) { nextPosition = size; ongoing=false; }
    req.url = `${url}?target=${target}`
    req.data = await file.slice(position,nextPosition).arrayBuffer()
    const resp = await axios(req)
    result = resp.data
    target = result.name // in case it was not specified in the input
    position = nextPosition
  }
  return result
}

function human_size (size) {
  // size: int (number of bytes)
  // returns a human readable string representing size
  const thr = 1024.
  const units = ['K','M','G','T','P','E','Z']
  if (size<thr) return `${size}B`
  size /= thr
  for (const u of units) {
    if (size<thr) return `${size.toFixed(2)}${u}iB`
    size /= thr
  }
  return `${size}YiB` // :-)
}

// short-hands

function encodeURIqs(uri,parm) {
  const q = Object.entries(parm).map((x)=>`${encodeURIComponent(x[0])}=${encodeURIComponent(x[1])}`).join('&')
  return `${uri}?${q}`
}

function addElement(container,tag,attrs) {
	const el = document.createElement(tag)
	if (attrs) { for (const [k,v] of Object.entries(attrs)) {el.setAttribute(k,v)} }
	container.appendChild(el)
	return el
}
function addJButton(container,icon,attrs) {
  const button = addElement(container,'button',attrs)
  addElement(button,'span',{class:`ui-icon ui-icon-${icon}`})
  return button
}
function addText(container,data) {
  const text = document.createTextNode(data||' ')
  container.appendChild(text)
}
function toggle_display (el) { el.style.display = (el.style.display?'':'none') }
function unsavedConfirm () { return window.confirm('Unsaved changes will be lost. Are you sure you want to proceed ?') }
function deleteConfirm () { return window.confirm('Are you sure you want to delete this entry ?') }
function noopAlert () { window.alert('Nothing to save !') }

class AjaxError extends Error {
  name = 'ajax'
  constructor (err) {
    if (err.response) { super(`Server error ${err.response.status} ${err.response.statusText}\n${err.response.data}`) }
    else if (err.request) { super(`No response received from Server\n${err.request.url}`) }
    else { super(err.message) }
  }
}

export { upload, human_size, encodeURIqs, addElement, addJButton, addText, toggle_display, unsavedConfirm, deleteConfirm, noopAlert, AjaxError }
